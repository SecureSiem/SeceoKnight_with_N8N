{
  "name": "EmailPhishingDetection",
  "nodes": [
    {
      "parameters": {
        "pollTimes": {
          "item": [
            {
              "mode": "everyMinute"
            }
          ]
        },
        "filters": {
          "includeSpamTrash": false,
          "includeDrafts": false,
          "labelIds": [
            "UNREAD"
          ],
          "q": "label:unread -in:trash -in:spam",
          "readStatus": "unread",
          "sender": ""
        }
      },
      "type": "n8n-nodes-base.gmailTrigger",
      "typeVersion": 1.3,
      "position": [
        -800,
        -272
      ],
      "id": "5dedaae5-6fae-4e41-a35a-ccff5427eada",
      "name": "Gmail Trigger",
      "credentials": {
        "gmailOAuth2": {
          "id": "kMdnA6c0XGnEmU8O",
          "name": "Gmail account"
        }
      }
    },
    {
      "parameters": {
        "operation": "get",
        "messageId": "={{ $json.id }}",
        "simple": false,
        "options": {
          "downloadAttachments": true
        }
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [
        -592,
        -272
      ],
      "id": "d2529327-af22-426d-969a-3e3a3044122f",
      "name": "Get a message",
      "webhookId": "2c215fb9-26c0-4035-bac6-cd371c8ab8dd",
      "credentials": {
        "gmailOAuth2": {
          "id": "kMdnA6c0XGnEmU8O",
          "name": "Gmail account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// üî• DUAL-MODE: Forwarded + Direct Emails!\nconst data = $input.item.json;\nconsole.log('üîç DATA KEYS:', Object.keys(data));\n\n// 1. Extract IP from headers.received\nconst receivedHeader = data.headers?.received || '';\nconsole.log('üìß RECEIVED:', receivedHeader.substring(0, 200));\nconst ipMatch = receivedHeader.match(/\\[\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\]/);\nconst forwardIP = ipMatch ? ipMatch[0].slice(1, -1) : 'NO_IP';\nconsole.log('üåê Forward IP:', forwardIP);\n\n// 2. SPF/DKIM/DMARC from authentication-results\nconst authResults = data.headers?.['authentication-results'] || data.headers?.['arc-authentication-results'] || '';\nconsole.log('üîê AUTH:', authResults.substring(0, 200));\n\n// Extract sender IP\nconst senderIPMatch = authResults.match(/\\[(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})\\]/);\nconst senderIP = senderIPMatch ? senderIPMatch[1] : forwardIP;\nconsole.log('üåê Sender IP:', senderIP);\n\nconst spfStatus = authResults.includes('spf=pass') ? '‚úÖ PASS' : '‚ùå FAIL';\nconst dkimStatus = authResults.includes('dkim=pass') ? '‚úÖ PASS' : '‚ùå FAIL';\nconst dmarcStatus = authResults.includes('dmarc=pass') ? '‚úÖ PASS' : '‚ùå FAIL';\n\n// 3. DUAL-MODE SENDER DETECTION\nconst textContent = data.text || data.html || '';\nconsole.log('üìÑ TEXT PREVIEW:', textContent.substring(0, 300));\n\n// FORWARDED: Extract from forwarded message\nlet originalSender = 'unknown';\nconst forwardedMatch = textContent.match(/From:\\s*[^<\\n]+<([^>]+)>/i) || \n                      textContent.match(/From:\\s+([^\\s<]+@[^\\s\\n>]+)/i) ||\n                      textContent.match(/----------\\s+Forwarded message\\s+----------\\s+From:\\s+[^<]*<([^>]+)>/i);\nif (forwardedMatch) {\n  originalSender = forwardedMatch[1];\n  console.log('üîç FORWARDED sender:', originalSender);\n} else {\n  // DIRECT: Use email From header\n  originalSender = data.from?.text || data.From || data.from || 'unknown';\n  console.log('üîç DIRECT sender:', originalSender);\n}\n\n// 4. URL/DOMAIN EXTRACTION (both modes)\nconst urls = (data.html || textContent).match(/https?:\\/\\/[^<>\"'\\s]+/gi) || [];\nconsole.log('üîó URLS:', urls.slice(0, 3));\nconst domains = urls.map(url => {\n  const match = url.match(/https?:\\/\\/([^\\/]+?)(?:\\?|\\/|$)/i);\n  return match ? match[1].replace('www.', '') : null;\n}).filter(Boolean);\nconst uniqueDomains = [...new Set(domains)];\n\n// üî• PRODUCTION DYNAMIC SUSPICIOUS DETECTION\nconst suspiciousDomains = uniqueDomains.filter(domain => {\n  const randomPattern = /^[a-z0-9]{4,}\\.[a-z0-9]{2,}\\.[a-z0-9]{2,}\\./i;\n  const suspiciousWords = /track|open|click|functions|bit|tiny|redirect|go\\.|lnkd\\.|t\\.|h\\./i;\n  const weirdTLD = /\\.(tk|ml|ga|cf|gq|xyz)$/i;\n  const tooManySubdomains = /^([a-z0-9-]{2,}\\.){3,}/i;\n  \n  return randomPattern.test(domain) || suspiciousWords.test(domain) || weirdTLD.test(domain) || tooManySubdomains.test(domain);\n});\n\n// Phish keywords\nconst phishKeywords = /secret|click|free|urgent|login|verify|account|password|bank|payment/i.test(textContent);\n\nreturn [{\n  json: {\n    employeeForwarder: data.from?.text || data.From || 'unknown',\n    forwardIP,\n    senderIP,\n    originalPhishSender: originalSender,\n    isForwarded: !!forwardedMatch,  // NEW: Detect mode!\n    suspiciousDomains,\n    allDomains: uniqueDomains.slice(0, 5),\n    spfStatus,\n    dkimStatus,\n    dmarcStatus,\n    phishScore: (suspiciousDomains.length * 20) + (phishKeywords ? 30 : 0),\n    isPhishing: suspiciousDomains.length > 0 || phishKeywords,\n    debugText: textContent.substring(0, 200),\n    debugAuth: authResults.substring(0, 200)\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -416,
        -272
      ],
      "id": "ba928aab-1dab-4474-9c3d-30c150ca6d2f",
      "name": "Parse Forwarded Phish"
    },
    {
      "parameters": {
        "url": "=https://api.abuseipdb.com/api/v2/check?ipAddress={{ $('Parse Forwarded Phish').first().json.senderIP }}&maxAgeInDays=90",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Key",
              "value": "ee8318a44fea92403abb24b208a93818272bf0a4e806111fa949aa42fde1a3356874d391e3d64320"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        144,
        -160
      ],
      "id": "0c0e5107-e28d-47d0-98fb-3121004948b9",
      "name": "IP Abuse Score"
    },
    {
      "parameters": {
        "url": "=https://dns.google/resolve?name={{ $('Parse Forwarded Phish').first().json.originalPhishSender.split('@')[1] }}&type=MX\n",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/dns-json"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        544,
        -112
      ],
      "id": "83e8b357-d195-4ce8-96ec-9f2976f60034",
      "name": "MX + SPF Lookup"
    },
    {
      "parameters": {
        "url": "=https://dns.google/resolve?name={{ $('Parse Forwarded Phish').first().json.originalPhishSender.split('@')[1] }}&type=TXT\n",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/dns-json"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        688,
        -176
      ],
      "id": "38ab8028-b5cd-4198-87e1-d86a992fb8d6",
      "name": "SPF Lookup"
    },
    {
      "parameters": {
        "url": "=https://dns.google/resolve?name=_dmarc.{{ $('Parse Forwarded Phish').first().json.originalPhishSender.split('@')[1] }}&type=TXT\n",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/dns-json"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        848,
        -176
      ],
      "id": "9b4ff8f9-9641-491e-8af4-77aeebc2aff4",
      "name": "DMARC Lookup"
    },
    {
      "parameters": {
        "jsCode": "// üî• DOMAIN RISK SCORING EXECUTED!\nconst phishData = $('Parse Forwarded Phish').item.json;\nconst dmarcLookup = $('DMARC Lookup').first().json;\nconst spfLookup = $('SPF Lookup').first().json;\n\nconst domains = phishData.suspiciousDomains || [];\nconst mainDomain = phishData.originalPhishSender.split('@')[1];\nconst suspiciousDomain = domains[0] || mainDomain;\n\n// Check SPF records existence\nconst allSpfRecords = spfLookup.Answer || [];\nconst realSpfRecords = allSpfRecords.filter(record => record.data.includes('v=spf1'));\nconst hasSpf = realSpfRecords.length > 0;\n\n// Check DMARC status\nconst dmarcRecord = dmarcLookup.Answer?.[0]?.data || '';\nconst noDmarc = dmarcLookup.Status === 3 || !dmarcRecord.includes('p=');\n\n// Existing heuristics\nconst riskFactors = {\n  trackers: domains.some(d => /wow|click|functions|track|open/i.test(d)),\n  unusualSubdomain: domains.some(d => d.includes('.') && !d.includes('google.com')),\n  phishKeywords: /secret|click|free|urgent|genius|effect/i.test(phishData.debugText || ''),\n  disposableEmail: /temp|guerrilla|10minutemail/i.test(mainDomain)\n};\n\n// Base risk calculation\nlet domainRiskScore = 0;\n\n// Penalize missing DMARC heavily\nif (noDmarc) {\n  domainRiskScore += 60; // Critical risk for missing DMARC\n}\n\n// Penalize missing SPF moderately\nif (!hasSpf) {\n  domainRiskScore += 30; // Moderate risk for missing SPF\n}\n\n// Add existing heuristic scores\ndomainRiskScore += \n  (riskFactors.trackers ? 30 : 0) + \n  (riskFactors.unusualSubdomain ? 25 : 0) + \n  (riskFactors.phishKeywords ? 25 : 0) + \n  (riskFactors.disposableEmail ? 20 : 0);\n\nreturn [{\n  json: {\n    suspiciousDomain,\n    mainDomain,\n    hasSpf,\n    noDmarc,\n    domainRiskScore: Math.min(100, domainRiskScore),\n    riskFactors,\n    domainVerdict: domainRiskScore > 70 ? 'üî¥ HIGH RISK' : domainRiskScore > 50 ? 'üü° MEDIUM' : 'üü¢ LOW',\n    overallRisk: phishData.phishScore + domainRiskScore > 150 ? 'üö® BLOCK!' : '‚ö†Ô∏è REVIEW'\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1008,
        -176
      ],
      "id": "04a5d9c9-f6b1-490e-8c21-c1bfd98de5f6",
      "name": "Domain Risk Score"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://hooks.slack.com/services/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",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.slackPayload }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        1152,
        160
      ],
      "id": "e802000f-aca6-4a8d-bfac-f88dbadd8676",
      "name": "Slack Blocks JSON"
    },
    {
      "parameters": {
        "jsCode": "// Get ALL data sources\nconst domainRisk = $input.first().json;\nconst merged = $('Merge Paths').first().json;\nconst mx = $('MX + SPF Lookup').first().json;\nconst spfLookup = $('SPF Lookup').first().json;\nconst dmarcLookup = $('DMARC Lookup').first().json;\n\n// Clean DNS data\nconst mxRecords = mx.Answer?.[0]?.data || 'No MX';\nconst allSpfRecords = spfLookup.Answer || [];\nconst realSpfRecords = allSpfRecords.filter(record => record.data.includes('v=spf1'));\nconst spfRecord = realSpfRecords[0]?.data || 'No SPF Record';\nconst dmarcRecord = dmarcLookup.Answer?.[0]?.data || 'No DMARC';\n\nconst allLinks = (merged.allUrls || []).slice(0,3).join('\\n') || 'None';\n\n// üî• REAL PHISH DOMAIN CHECKS (DYNAMIC!)\nconst phishDomain = merged.originalPhishSender.split('@')[1];\nconst realSpfStatus = realSpfRecords.length > 0 ? '‚úÖ REAL SPF' : '‚ùå NO SPF';\nconst realDmarcStatus = dmarcLookup.Status === 3 || !dmarcRecord.includes('p=') ? '‚ùå NO DMARC' : '‚úÖ REAL DMARC';\n\n// üî• DYNAMIC IP DISPLAY (UPDATED)\nconst ipAbuseScore = merged.data?.abuseConfidenceScore || 0;\nconst senderIP = merged.senderIP || 'Unknown';\nconst forwardIP = merged.forwardIP || senderIP;\nconst isGmailIP = senderIP.startsWith('209.85.') || senderIP.startsWith('64.233.') || senderIP.startsWith('66.102.');\nconst ipSource = isGmailIP ? 'Gmail Forward IP' : senderIP === forwardIP ? 'Forward IP' : 'Original IP Found';\nconst ipDisplay = `${ipAbuseScore}\\n(${ipSource})\\nSender IP: ${senderIP}\\nForward IP: ${forwardIP}`;\n\n// üî• SMART TOTAL RISK CALCULATION\nconst totalRisk = (merged.phishScore || 0) + \n                  (domainRisk.domainRiskScore || 0) + \n                  (merged.urlRiskScore || 0) + \n                  ipAbuseScore;\n\n// üî• SMART VERDICT\nconst verdict = totalRisk < 100 ? 'üü¢ LEGIT' : \n                totalRisk < 150 ? 'üü° REVIEW' : \n                totalRisk < 200 ? 'üü† MARKETING PHISH' : 'üö® HIGH RISK PHISH';\n\nconst actionText = totalRisk < 100 ? '‚úÖ ALLOW (Safe)' : \n                   totalRisk < 150 ? '‚ö†Ô∏è REVIEW + Block Trackers' : \n                   totalRisk < 200 ? 'üö® BLOCK Trackers + Links' : '‚ùå BLOCK EMAIL NOW!';\n\nreturn [{\n  json: {\n    slackPayload: {\n      blocks: [\n        {\"type\": \"header\", \"text\": {\"type\": \"plain_text\", \"text\": \"üö® ENTERPRISE SIEM LIVE\"}},\n\n        // Forwarder vs REAL sender\n        {\n          \"type\": \"section\",\n          \"fields\": [\n            {\"type\": \"mrkdwn\", \"text\": `*üë§ Forwarded By:*\\n${merged.employeeForwarder}`},\n            {\"type\": \"mrkdwn\", \"text\": `*üìß REAL Sender:*\\n${merged.originalPhishSender}`}\n          ]\n        },\n\n        // Risk Scores Section\n        {\n          \"type\": \"section\",\n          \"fields\": [\n            {\"type\": \"mrkdwn\", \"text\": `*Phish Score:*\\n${merged.phishScore || 0}`},\n            {\"type\": \"mrkdwn\", \"text\": `*Domain Risk:*\\n${domainRisk.domainRiskScore || 0} ${domainRisk.domainVerdict || 'N/A'}`},\n            {\"type\": \"mrkdwn\", \"text\": `*URL Risk:*\\n${merged.urlRiskScore || 0}`},\n            {\"type\": \"mrkdwn\", \"text\": `*IP Abuse:*\\n${ipDisplay}`}\n          ]\n        },\n\n        // VirusTotal Section\n        {\n          \"type\": \"section\",\n          \"fields\": [\n            {\"type\": \"mrkdwn\", \"text\": `*üõ°Ô∏è VirusTotal:*\\n${merged.vtStatus}`},\n            {\"type\": \"mrkdwn\", \"text\": `*üö© Top Threat:*\\n${merged.topThreat?.split('/')[2] || merged.topDomain || 'None'}`}\n          ]\n        },\n\n        // ALL LINKS Section\n        {\"type\": \"section\", \"text\": {\"type\": \"mrkdwn\", \"text\": `*üîó ALL LINKS:*\\n${allLinks}`}},\n\n        // Gmail vs Real Auth Section\n        {\n          \"type\": \"section\",\n          \"fields\": [\n            {\"type\": \"mrkdwn\", \"text\": `*üõ°Ô∏è GMAIL AUTH:*\\n${merged.spfStatus} ${merged.dkimStatus} ${merged.dmarcStatus}`},\n            {\"type\": \"mrkdwn\", \"text\": `*üö® REAL ${phishDomain}:*\\n${realSpfStatus} | ${realDmarcStatus}`}\n          ]\n        },\n\n        // DNS Records Section\n        {\"type\": \"divider\"},\n        {\n          \"type\": \"section\",\n          \"text\": {\n            \"type\": \"mrkdwn\",\n            \"text\": `*üåê DNS ${phishDomain}:*\\nüì¨ MX: ${mxRecords}\\nüõ°Ô∏è SPF: ${spfRecord.substring(0,40)}...\\n‚ö†Ô∏è DMARC: ${dmarcRecord.substring(0,60)}...`\n          }\n        },\n\n        {\"type\": \"divider\"},\n\n        // Verdict Section\n        {\n          \"type\": \"section\",\n          \"text\": {\n            \"type\": \"mrkdwn\",\n            \"text\": `*üéØ VERDICT: ${verdict}*\\n*Total Risk: ${Math.round(totalRisk)}*\\n*‚û°Ô∏è ACTION: ${actionText}`\n          }\n        }\n      ]\n    }\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1344,
        -176
      ],
      "id": "fec9eacd-353c-4695-8cac-cb4358307279",
      "name": "Build Slack Blocks"
    },
    {
      "parameters": {
        "jsCode": "const phish = $('Parse Forwarded Phish').first().json;\n\n// Get ALL possible text sources (NO base64 decoding)\nconst sources = [\n  $input.first().json.html || '',\n  $input.first().json.text || '',\n  phish.debugText || ''\n].join('\\n');\n\nconsole.log('üìß TEXT LENGTH:', sources.length);\nconsole.log('üîç SAMPLE:', sources.substring(0, 200));\n\n// Simple URL regex\nconst urlRegex = /https?:\\/\\/[^\\s<>\"'[\\s]+/gi;\nconst urls = sources.match(urlRegex) || [];\n\n// Domain-based URLs (your domains ARE clickable!)\nconst domains = phish.allDomains || phish.suspiciousDomains || [];\nconst domainUrls = domains.map(d => `https://${d}`);\n\nconst allUrls = [...new Set([...urls, ...domainUrls])];\nconst suspiciousUrls = allUrls.filter(url => \n  /click|track|open|functions|delivery|bit|tiny/i.test(url.toLowerCase())\n);\n\nconsole.log('üîó URLS:', urls.length, 'DOMAINS:', domainUrls.length, 'SUSPICIOUS:', suspiciousUrls.length);\n\nreturn [{\n  json: {\n    allUrls,\n    suspiciousUrls,\n    totalUrls: allUrls.length,\n    suspiciousCount: suspiciousUrls.length,\n    urlRiskScore: Math.min(100, suspiciousUrls.length * 20),\n    topThreat: suspiciousUrls[0] || null,\n    hasPhishyLinks: suspiciousUrls.length > 0,\n    ...phish\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -256,
        -272
      ],
      "id": "515ef115-c79f-4c37-8375-22bce9bf4810",
      "name": "Extract URLs"
    },
    {
      "parameters": {
        "preBuiltAgentsCalloutHttpRequest": "",
        "httpVariantWarning": "",
        "curlImport": "",
        "method": "GET",
        "": "",
        "url": "={{ $('Extract URLs').first().json.topThreat || $('Extract URLs').first().json.allUrls[0] || 'https://example.com' }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "virusTotalApi",
        "provideSslCertificates": false,
        "sendQuery": false,
        "sendHeaders": false,
        "sendBody": false,
        "options": {
          "response": {
            "response": {
              "fullResponse": false,
              "neverError": true,
              "responseFormat": "autodetect"
            }
          }
        },
        "infoMessage": ""
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        144,
        -336
      ],
      "id": "244d86bd-b1ec-479f-8864-6ac8822b0882",
      "name": "VirusTotal HTTP Request",
      "extendsCredential": "virusTotalApi",
      "credentials": {
        "virusTotalApi": {
          "id": "EK4AZvVIcTWDOh5D",
          "name": "VirusTotal account 2"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const vtResponse = $('VirusTotal HTTP Request').first().json;\nconst urls = $('Extract URLs').first().json;\n\nlet vtStatus = 'üü¢ CLEAN';\nlet topDomain = urls.topThreat ? urls.topThreat.split('/')[2] : (urls.allUrls[0] ? urls.allUrls[0].split('/')[2] : 'None');\n\nif (vtResponse.data && vtResponse.data.attributes && vtResponse.data.attributes.last_analysis_stats) {\n  const stats = vtResponse.data.attributes.last_analysis_stats;\n  const malicious = stats.malicious || 0;\n  const suspicious = stats.suspicious || 0;\n  vtStatus = malicious > 0 ? `üö® ${malicious} MALWARE` : \n             suspicious > 0 ? `üü° ${suspicious} SUSPICIOUS` : `üü¢ CLEAN (${topDomain})`;\n} else if (vtResponse.statusCode === 404 || (vtResponse.data && vtResponse.data.includes && vtResponse.data.includes('404'))) {\n  vtStatus = `üü¢ CLEAN (New: ${topDomain})`;\n} else {\n  vtStatus = `üü¢ NO DETECTIONS (${topDomain})`;\n}\n\nreturn [{\n  json: {\n    vtStatus,\n    topDomain,\n    ...urls\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        336,
        -336
      ],
      "id": "12fa3e39-2b48-4baf-92b9-c02f463b835c",
      "name": "VT Handler"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        384,
        -112
      ],
      "id": "60697d8d-d2e7-45a4-968c-d1166983be80",
      "name": "Merge Paths"
    }
  ],
  "pinData": {},
  "connections": {
    "Gmail Trigger": {
      "main": [
        [
          {
            "node": "Get a message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get a message": {
      "main": [
        [
          {
            "node": "Parse Forwarded Phish",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Forwarded Phish": {
      "main": [
        [
          {
            "node": "Extract URLs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IP Abuse Score": {
      "main": [
        [
          {
            "node": "Merge Paths",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "MX + SPF Lookup": {
      "main": [
        [
          {
            "node": "SPF Lookup",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SPF Lookup": {
      "main": [
        [
          {
            "node": "DMARC Lookup",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DMARC Lookup": {
      "main": [
        [
          {
            "node": "Domain Risk Score",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Domain Risk Score": {
      "main": [
        [
          {
            "node": "Build Slack Blocks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Slack Blocks": {
      "main": [
        [
          {
            "node": "Slack Blocks JSON",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract URLs": {
      "main": [
        [
          {
            "node": "VirusTotal HTTP Request",
            "type": "main",
            "index": 0
          },
          {
            "node": "IP Abuse Score",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "VirusTotal HTTP Request": {
      "main": [
        [
          {
            "node": "VT Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "VT Handler": {
      "main": [
        [
          {
            "node": "Merge Paths",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Paths": {
      "main": [
        [
          {
            "node": "MX + SPF Lookup",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "027b657a-54ae-4a12-b52a-daf616da04b9",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "d7fd36c8cfab19e41840b974db914b5932d1d831fc0c8e87baf72d45b7f6ede0"
  },
  "id": "Q62n4i7iq5HcUH0I",
  "tags": []
}